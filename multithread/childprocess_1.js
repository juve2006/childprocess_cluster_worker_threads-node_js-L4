/**
 *  Коли користувач запускає одну програму Node.Js, вона працює як один процес операційної системи (ОС),
 * який представляє екземпляр запущеної програми.
 *  В рамках цього процесу, Node.js виконує програму в одному Треді. В одному процесі, може винуватись тільки один тред,
 * і якщо задача яку ви задали є важка і займає час, відповідно тред буде заблокований, допоки вона не виконається.
 *  Відповідно, коли виникають довготривалі задачі, краще їх виконувати "на стороні" і не блокувати головний процес.
 * Реалізувати це можна з-за допомогою запуску дочірнього процесу, або процесу створеного іншим процесом.
 * При запуску нового процесу, ОС може використовувати багатопроцесорні техніки, щоб розпаралелити процеси і виконати задачу паралельно
 *
 * Node.Js включає модуль child_process, який має функції для створення нових процесів, взаємодії з ОС, та запуском команд оболонки.
 *
 * */

/**
 * До прикладу, запуск команди в дочірньому процесі. Функція exec() створить новий процес оболонки, в якому виконає команду.
 * Оболонка потрібна, щоб команди знаходились в одному рядку з аргументами.
 * Дані повертає через функцію callback
 *
 * Error - помилка яка створена Node.Js, повязана з тим, що є проблема виконання вашої команди ( синтаксис )
 * Stderr - стрім, який трапляється тому що, щось пішло не так, під час виконання вашої команди
 * */
const { exec } = require('child_process');

exec('ls -lh', (error, stdout, stderr) => {
    if (error) {
        console.error(`error: ${error.message}`);
        return;
    }

    if (stderr) {
        console.error(`stderr: ${stderr}`);
        return;
    }

    console.log(`stdout:\n${stdout}`);
});

/**
 * Функція spawn() запускає команду в новому процесі, та повертає дані через стандартні I/O потоки. Ця функція не створює оболонку,
 * тому всі аргументи повинні бути задані в масиві
 * */
// const { spawn } = require('child_process');
//
// const child = spawn('find', ['.']);
//
// child.stdout.on('data', (data) => {
//     console.log(`stdout:${data}`);
// });
//
// child.stderr.on('data', (data) => {
//     console.error(`stderr: ${data}`);
// });
//
// child.on('error', (error) => {
//     console.error(`error: ${error.message}`);
// });
//
// child.on('close', (code) => {
//     console.log(`child process exited with code ${code}`);
// });

/**
 * Функція fork(), основною перевагою використання цієї функції є те, що вона забезпечує комунікацію між батьківським та дочірнім процесом.
 * З-за допомоги fork(), крімо отримання даних з дочірнього процесу, батьківський процес може відправляти повідомлення в дочірній процес.
 * Аналогічним чином, дочірній процес може відправляти повідомлення в батьківський процес
 *
 * Проблема fork: що на процесі, вони запускають нову віртуальну машину ( копію ОС ), де виконують код та повертають результат через івент.
 * Тобто віртуальна машина та ОС система створюють I/O потік, по якому обмінюються повідомленнями.
 *
 * Віртуальна машина використовує багато ресурсів. ( оперативної памяті (CPU) ). Також через те, що форк клонує ОС, та піднімає свою,
 * дані не є узгоджені. Тобто якщо буде два форки, перший і другий щось поміняє, змін які робив перший, не буде в другому.
 *
 * Тобто форкнуті процеси, використовують память не спільно. Також якщо одне завдання завалилось в помилку, всі інші які були послані,
 * на цей процес, будуть не закінчені.
 * */
// const http = require('http');
// const { fork } = require('child_process');
//
// const host = 'localhost';
// const port = 8000;
//
// const requestListener = function (req, res) {
//     const child = fork(__dirname + '/fork_process');
//
//     child.on('message', (message) => {
//         console.log('Returning results');
//
//         res.setHeader('Content-Type', 'application/json');
//         res.writeHead(200);
//         res.end(message);
//     });
//
//     child.send('START');
// };
//
// const server = http.createServer(requestListener);
//
// server.listen(port, host, () => {
//     console.log(`Server is running on http://${host}:${port}`);
// });
