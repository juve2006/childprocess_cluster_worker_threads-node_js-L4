/**
 * Кластер базується на child_process і є зручною обгорткою над цим пакетом.
 * Кластер може створювати кілька процесів Node.Js з одним головним процесом, що маршрутизує запити між ними.
 * Кластизація програми дозволяє ефективно збільшити пропускну здатність сервера.
 *
 * Для оптимізації роботи у багатоядерних системах, користувачі можуть запустити кластер процесів Node.js ,
 * щоб розділити навантаження між ядрами процесора/процесорами. Створюються дочірні процеси, які поділяються на серверні порти.
 *
 * Тобто кластеризація це - запуск декількох екземплярів одної аплікації, для розподілення між ними запитів які надходять.
 * Для отримання максимальної потужності, кількість запущених екземплярів не має перевищувати кількість ядрів на комп'ютері.
 *
 * Є головний процес - Master, та дочірні процеси - Worker.
 *
 * Процеси воркерів породжуються методом child_process.fork (), таким чином вони можуть обмінюватись даними двосторонньо з батьківським процесом.
 * Модуль cluster підтримує два методи розподілу з'єднань:
 * - Перший і встановлений за замовчуванням: головний процес слухає порт, приймає нові з'єднання і разділяє їх між воркерами по колу, стежачи при цьому,
 *   щоб воркери не перевантажувались.
 * - Другий: головний процес створює та слухає сокет і засилає його воркерам, воркери в свою чергу приймають з'єднання напряму.
 *
 * Другий підхід теоретично повинен давати кращу продуктивність, однак в дійсності розподіл при цьому стає дуже незбалансованим
 * через особливості менеджера завдань операційної системи. За спостереженнями 70% всіх з'єднань потрапляють в всього два з восьми процесів.
 *
 * Оскільки воркери - це окремі процеси, вони можуть бути видалені або перезапущені в залежності від потреб програми, не зачіпаючи решту воркерів.
 * Поки хоч один воркер продовжує працювати, сервер продовжить приймати з'єднання. Якщо більше немає працюючих воркерів, існуючі з'єднання будуть скинуті,
 * і нові не будуть прийматися. При цьому Node.js не керує кількістю воркерів. Додаток має саме займатися управлінням воркерами в залежності від своїх потреб.
 **/

const cluster = require('cluster');
const http = require('http');
const os = require('os');

if (cluster.isMaster) {
    const cpusCount = os.cpus().length;

    console.log(`Master ${process.pid} is running`);

    // Fork workers.
    for (let i = 0; i < cpusCount; i++) {
        const worker = cluster.fork();
        

        worker.on('exit', (worker, code, signal) => {
            console.log(`worker ${worker.process.pid} died`);
            console.log('Starting a new worker....');
            cluster.fork();
            console.log(`Worker ${process.pid} started`);
        });

    }
} else {
    http.createServer((req, res) => {
        console.log(`Worker ${process.pid}: WORKED`);
        res.writeHead(200);
        res.end('hello world');
    }).listen(3000);

    console.log(`Worker ${process.pid} started`);
}

